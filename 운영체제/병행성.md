> 병행성 : Deadlock
>
> - 병행성 제어 : Wait Free / Th**read Safe** / Peterson's Algorithm / Race Condition

# 2. 병행성

## Deadlock

Deadlock은 **두 개 이상의 프로세스나 스레드가 서로가 소유한 자원을 기다리며 무한정 대기하는 상태를 말한다.** 이러한 상황은 각 프로세스나 스레드가 서로 다른 프로세스나 스레드가 소유한 자원을 요청하면서 발생한다. 이 결과, 어떤 프로세스나 스레드도 자신의 작업을 진행시킬 수 없게 되는 상황이 발생합니다

- 식사하는 철학자 문제 : Deadlock을 설명하기 위한 예제. 원형 테이블에 앉아 있는 5명의 철학자들이 스파게티를 먹으려고 하고 있고, 철학자들 사이에 포크가 놓여있다. 각 철학자는 자신의 왼쪽과 오른쪽에 하나씩 두 개의 포크를 사용해야 스파게티를 먹을 수 있고 철학자들은 포크를 한 번에 하나씩만 사용할 수 있다.
  철학자들이 동시에 식사를 시작하면, 각 철학자는 오른쪽 포크를 먼저들고 그 다음 왼쪽을 들게 되는데 이 경우 모든 사람이 오른쪽 포크를 가지게 되므로 아무도 식사를 할 수 없게 된다. 이러한 상황이 데드락의 예시 중 **순환 대기를 하는 예시**이다.

데드락은 OS의 병행 제어 매커니즘(mutext, 세마포어)뿐만이 아니라 다양한 시스템 및 애플리케이션에서 통용되는 개념이다. 예를 들어 데이터 베이스에서 두 개 이상의 트랜잭션이 서로의 작업을 완료하기 위해 상대방이 들고 있는 자원을 기다리는 상황에서 발생할 수 있다.
특히 병행 제어 매커니즘에서는 **스레드 끼리의 자원의 공유** 때문에 Deadlock이 발생합니다. mutex를 예로 들어보자. 두 개의 스레드가 각각 서로 다른 mutex를 소유하고 있고, 동시에 서로의 mutex를 요청하는 상황에서 데드락이 발생할 수 있습니다.

### Deadlock의 네 가지 조건

이 네 가지 조건은 데드락의 필요조건이므로 네 가지 조건이 충족되더라도 데드락이 발생하지 않을 수 있습니다. 또한 이들 중 하나라도 만족하지 않는다면 데드락이 발생하지 않는다.

- **Mutual Exclusion, 상호 배제** : **한 번에 한 개의 프로세스만이 자원을 사용할 수 있다.** 따라서 **어떤 스레드가 해당 자원에 접근했을 때 이미 자원이 사용 중이라면 해당 자원을 위하여 대기**해야 합니다. 만약 이 조건이 만족되지 않는다면 한 번에 여러 개의 프로세스가 자원을 사용할 수 있으므로 자원을 위하여 프로세스들이 기다려야 하는 상황이 발생하지 않는다.
- **Hold and Wait, 점유와 대기** : **프로세스가 최소한 하나의 자원을 점유한 채 놔주지 않고 다른 자원을 획득하기 위해 대기하는 상황**을 뜻한다. 프로세스가 이미 자원을 하나 이상 가지고 있는 상태에서 다른 자원을 요구하고, 그 자원이 다른 프로세스에게 할당된 상태라면 그 자원을 가진 프로세스는 자원을 놔주고 있지 않으므로 해당 자원을 필요로하는 프로세스는 기다릴 수 밖에 없다.
- **No Preeemption, 비선점** : **자원을 획득하지 않은 다른 스레드에 의해 자원이 선점당하지 않는다, 즉 운영체제에 의하여 자원이 강제적으로 빼앗기지 않는다.** 즉, 운영체제가 필요할 경우 자원을 강제적으로 빼앗을 수 없습니다. 이 조건이 만족되지 않는 다면 운영체제가 프로세스에게 자원을 강제적으로 빼앗을 수 있다는 의미이므로 데드락이 발생하지 않는다.
- **Circular Wait, 순환 대기** : 프로세스의 집합 P1, P2, ... , Pn이 있다고 하겠습니다. 이 때 P1는 P2의 자원을, P2는 P3의 자원을 ... Pn은 P1의 자원을 기다리고 있는 상태입니다.

### Deadlock을 해결할 수 있는 방법

- **Deadlock 예방** : **교착 상태의 4가지 필요조건이 전부 만족 되어야 교착 상태가 발생할 수 있다는 사실**에 기반한다. 따라서 **4가지 조건 중 한 개 이상이 절대 일어날 수 없게 한다**. 보통 순환 대기를 막는 방법이 실용적이라고 평가된다.
  - 순환 대기를 막는 방법 : 위에서 언급한 식사하는 철학자 문제를 생각해보자. 이 문제에서 각 수저에 번호를 매기고 철학자가 낮은 포크부터 먼저 집어들도록 규칙을 정하면 데드락을 막을 수 있다. 즉, 락에 번호를 매기고 모든 스레드가 락을 획득하는 순서를 오름차순으로 일치시키는 방식을 사용해볼 수 있다.
- **Deadlcok 회피**
  - **스레드가 모든 시간 동안 언제 어떤 자원을 필요로 할 지에 대한 정보를 가지고, 이 정보에 기반해 교착 상태가 생길 것을 미연에 판단하고 회피한다.**
  - 이 때, 자원 할당 그래프 알고리즘을 이용하여 사이클 탐지 알고리즘으로 교착 상태가 생길지 판단한다.
- **데드락 감지 및 해결**
  **- 시스템이 데드락을 주기적으로 검**사하고, 데드락이 감지되면 이를 해결한다.
  - **프로세스와 스레드의 종료** : 프로세스를 모두 종료시키거나, 데드락이 해결 될 때 까지 하나씩 프로세스를 중지시킨다.
  - **자원 선점** : 데드 락에서 빠져나올 수 있도록 자원을 운영체제가 프로세스로부터 뺏어서 다른 프로세스에게 주는 작업을 반복함

현대 운영체제의 경우 대부분 데드락을 직접적으로 해결하는 시도를 하지는 않는다. 왜냐하면 데드락을 피하거나 해결하기 위해 필요한 자원과 계산 비용에 의한 성능 저하를 더 큰 문제라고 판단하기 때문이다

## 병행성 제어

### Wait Free와 Lock Free

Wait Free와 Lock Free는 멀티 스레딩 환경에서 **동시성을 처리하는 두 가지 방법론**이다. 이 기법들 모**두 공유 자원에 대한 동시 접근을 허용하면서 blocking이나 deadlock 없이 실행을 보장**한다.

- **Wait-Free** : **모든 스레드가 계속해서 진행함을 보장**한다. 따라서 어떤 스레드도 다른 스레드에 의해 block되지 않는다. 이 방식은 시스템의 전체적인 처리량을 최적화하는 것보다 **모든 스레드가 일정한 속도로 진행할 수 있도록 한다.** 이러한 Wait-Free 방식은 **실시간 시스템이나 높은 반응성이 요구되는 시스템에서 자주 사용**한다. 하지만 **이러한 보장을 제공하는 것은 알고리즘이 복잡해지고 때로는 많은 오버헤드를 발생**시킨다.
- **Lock-Free** : **시스템 전체에서 적어도 하나의 스레드가 진행함을 보장**한다. 즉, 일부 스레드가 늦게 실행하거나 블록되더라도 어떤 스레드는 항상 작업을 완료할 수 있다.
  이 방식은 **시스템의 전체적인 처리량을 극대화하는데 더 중점**을 주며, 개별 스레드 보다 시스템 전체의 진행을 중시한다.
  Lock-Free 방식은 **일반적으로 구현이 더 간단하고 오버헤드가 적지만, 일부 스레드가 다른 스레드에 의해 계속해서 뒤로 밀릴 수 있다.**

### Thread Safe

주로 멀티 스레드 프로그래밍 환경에서 **여러 스레드가 동시에 실행하더라도 프로그램의 실행에 문제가 생기지 않는다는 것을 의미**한다. 즉, 공유 데이터의 일관성이 유지되고 예상치 못한 결과가 발생하지 않는다.

### Thread Safe를 위한 방법론

- **Mutual Exclusion** (상호 배제) : 공유 자원에 대한 접근을 한 번에 하나의 스레드만 할 수 있도록 제한.
  - mutex, semaphore, monitor 등의 동기화 매커니즘을 사용하여 구현
- **Reentrancy** (재진입성) : 코드가 중간에 중단되었다가 나중에 시작되어도 안전하게 동작하도록 만든다.
- Thread-Local Storage (스레드 지역 저장소) : 각 스레드가 자신만의 독립적인 데이터 저장소를 가지고 작업하도록 한다.
- **Atomic Operations** (원자 연산) : 연산이 중간에 방해받지 않고 한 번에 완료되도록 보장함

### Peterson's Algorithm

병행성 제어를 위한 방식 중 하나로 두 개의 프로세스가 임계 영역을 공유하면서 동시에 접근하는 것을 방지하는 알고리즘. 공유 자원에 대한 상호 배제를 보장하며, 임계 영역에 대한 접근을 조정하는데 사용한다.

- **작동 방식**
  1.  두 프로세스가 각각의 '플래그' 변수와 '턴' 변수를 공유한다. 플래그 변수는 해당 프로세스가 critical section에 접근하려고 하는지를 표시하며, 턴 변수는 critical section에 접근할 차례가 누구인지를 나타낸다.
  2.  프로세스가 critical section에 들어가려고 할 때, 그것의 플래그를 설정하고 턴을 다른 프로세스에 넘긴다.
  3.  프로세스는 자신의 플래그가 설정되어 있고, 턴이 자신에게 있지 않은 경우에만 critical section에 들어갈 수 있다. 이 경우가 아니면 턴이 돌아올 때 까지 기다린다.
  4.  프로세스가 critical section에서 빠져 나오면 그것의 플래그를 해제한다.
- **한계점**

  - Scalabillity : 이 알고리즘은 두 개의 프로세스에 대해서만 작동한다.
  - Busy Waiting : 프로세스가 계속하여 자신에게 턴이 돌아올 때 까지 확인하며 기다리므로 프로세서 시간이 낭비될 수 있다.
  - Atomic operation : 알고리즘에서의 연산들이 atomic하게 수행된다고 가정하지만, 하드웨어나 컴파일러가 이를 보장하지는 않는다.
  - 메모리 모델 : 알고리즘에서 제안하는 메모리 모델과 현대의 메모리 모델이 일치하지 않는다.

  따라서 현대의 대부분의 시스템에서는 Peterson's algorithm 대신 하드웨어 지원을 받는 lock 또는 다른 동기화 매커니즘을 사용한다.

### Race Condition

- **두 개 이상의 연산이 결과에 영향을 줄 수 있는 순서에 따라 실행될 때 발생하는 상황. 멀티 스레딩 환경에서 여러 스레드가 동일한 데이터에 동시에 접근하려고 시도할 때 발생**한다.
  - 다르게 설명하면 **두 개의 스레드가 동일한 critical sectoin에 접근하려고 시도할 때 발생**한다.
- 예를 들어 두 스레드가 동일한 메모리 위치에 동시에 쓴다고 하자. 어떤 스레드의 쓰기가 먼저 수행될지 (실행 순서에 따라) 결과가 달라질 수도 있다.
- 이를 해결하기 위해 mutex, semaphore, monitor와 같은 동기화 기법을 사용하며 critical section에 대한 동시 접근을 제한한다.
