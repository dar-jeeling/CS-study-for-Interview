##### 문제모음
- RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.
-   싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?
-   동시성과 병렬성의 차이에 대해 설명해 주세요.
-   타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?

#### 동시성과 병렬성
동시성 : 동시에 실행되는 것 처럼 보이는것 -> 싱글코어, 멀티코어에서 가능하다.
Context Switching을 통해 여러 프로세스를 돌아가며 작업을 처리한다.
![](https://i.imgur.com/JsmVqlI.png)

병렬성 : 실제로 동시에 실행되는 것 -> 멀티코어 에서만 가능하다.
![](https://i.imgur.com/U7Atk0q.png)


다중 프로그래밍이란 여러 프로세스를 동시에 메모리에 올려 놓고, 실행 중인 프로세스가 입출력을 요청하거나, 실행을 종료하면 운영체제가 이 프로세스에 할당된 프로세서를 회수하여 다른 프로세스에 할당하는 것이다. 

그렇다면 다중 프로그래밍을 하기 위해서는 어떤 프로세스에 할당할지에 대한 전략, 기술이 필요하다. 이때 사용되는 것이 프로세스 스케줄링이다. 

이제 스케줄링 알고리즘을 알아보기 전에, 스케줄링 알고리즘에 대한 평가기준을 먼저 알고 가자
평가 기준은
- 프로세스 사용률( ⬆️) : 시간당 CPU를 사용한 시간의 비율, 프로세스를 항상 실행상태로 유지한다.
- 처리율(⬆️) : 시간당 처리한 작업의 비율
- 응답시간(⬇️): 대기열에 들어오고 부터 처음으로 응답을 시작하는 시간
- 반환시간(⬇️) : 실행 종료까지의 시간
- 대기시간(⬇️) : 대기열에 들어와서 CPU를 할당받기까지 걸린 시간 or 대기열에 들어와서 실행되지않고, 기다린 시간
![](https://i.imgur.com/2SBMjDJ.png)


스케줄링 알고리즘은 크게 2가지로 나눌 수 있다.

- 선점 스케줄링 : 한 프로세스가 다른 프로세스의 자원을 빼앗을 수 있다. -> 우선순위가 높다면 실행되고 있던 프로세스를 멈출 수 있다.
- 비선점 스케줄링 : 한 프로세스가 다른 프로세스의 자원을 빼앗을 수 없다. 

#### 1. FCFS(First Come First Served) 스케줄링
	비선점 방법으로 프로세서를 요청 하는 순서대로 할당한다.
![](https://i.imgur.com/jgDU4zH.png)

- 장점
	1. 스케줄링의 이해와 구현이 단순하다.
	2. 모든 프로세스가 실행되기 때문에 기아가 없는 공정한 정책이다.
	3. ***프로세서가 지속적으로 유용한 프로세스를 수행하여 처리율이 높다. -> 왜..?***
- 단점
	1. 비선점이므로 빠른 답변이 필요한 대화식 작업에는 부적합하다.
	2. 앞에 있는 작업이 길 경우 뒤에있는 작업을 모두 지연시키는 현상이 발생한다.즉, 큰 프로세스 하나를 처리하여 프로세서를 떠나기를 기다리는 상태가 발생한다.( = 호위 효과) 그러므로 평균 대기시간이 길어진다.

#### 2. SJF(Shortest Job First) 스케줄링
	선점형과 비선점형 둘 다 있으며, CPU burst Time을 고려한다. 짧은것이 우선이다.

이때 CPU burst Time이란 프로세스가 CPU에서 실행되어야 하는 시간. 필요로 하는 시간이다.
![](https://i.imgur.com/a6LL76x.png)
	-> 비선점형

![](https://i.imgur.com/BIsP8gR.png)
	-> 선점형
	
- 장점
	1. 평균 대기시간이 가장 짧다. -> ~~항상 실행할 준비가 된 프로세스중 가장 짧은 프로세스를 실행하기 때문이다. 만약 이해가 안간다면, 실행할 준비가 되어있지 않은 프로세스를 사용하는 상황 or 가장 짧은 프로세스 말고 다른 프로세스를 실행하게 되는 상황을 생각해보자.
- 단점
	1. 긴 작업의 경우 기아상태가 될 수 있다. 그러므로 불공정한 작업이다.
	2. 실행 시간을 예측할 수 없어 비현실적이다.

#### 3. 우선순위 스케줄링
	우선순위에 따라 처리된다.
![](https://i.imgur.com/AYpsHk1.png)

- 장점
	1. 각 프로세스의 상대적 중요성을 정의할 수 있다. 
	2. 실시간 시스템에 적용이 가능하다. ->그렇기 때문에 싱글 스레드에서 상시로 돌아가야하는 프로세스가 있다면, 우선순위 스케줄링이 좋다.
- 단점
	1. 기아상태가 발생할 수 있다.

#### 4. 라운드 로빈 스케줄링
	각 프로세스에 CPU할당량을 부과해서 할당시간 내에 처리하지 못하면 다음프로세스로 넘어가는 선점형 방식이다. 이때 할당 시간을 Time Quantum 또는 Time Slice라고 한다.
![](https://i.imgur.com/Z3xRM9h.png)
위 그림에서 P1의 반환시간은 134이다.

- 장점
	1. 모든 프로세스가 동일한 점유율과 동일한 제한시간을 가지므로 기아 상태가 발생하지 않고, 공정하다.
	2. 구현이 쉽다.
	3. 작업 길이가 다양할 경우, 이전 작업을 마친 후 보다 규정 시간량을 마치고 다음 작업으로 이동하기 때문에 평균 대기시간이 FCFS, SJF보다 적다.
- 단점
	1. 만약 Time quantum이 커진다면 FCFS와 다를 바가 없어진다.
	2. 너무 짧을 경우는 너무 많은 Context Switching으로 부담이 크다.
	3. 하드웨어 타이머가 필요하다.
	4. 평균 처리 시간이 높다.

#### 5. MLQ(다단계 큐) 스케쥴링
	각 작업을 서로 다른 묶음으로 분류해서 사용할 수 있을때 사용한다.
	큐를 여러종류로 구분하고, 각 큐는 절대적인 우선 순위를 가진다. 즉, 우선순위가 높은 큐가 비어있기 전까지는 낮은 우선순위 큐를 실핼할 수 없다. 또한 큐 마다 독자적인 스케줄링을 가진다. 
![](https://i.imgur.com/VWSw19D.png)

- 장점
	1. 응답이 빠르다.
- 단점
	1. 여러 준비 큐와 스케줄링 알고리즘 때문에 추가 오버 헤드가 발생한다.
	2. 우선순위가 낮은 큐의 프로세스는 무한정 대기하는 기아가 발생할 수 있다.


#### 6. MLFQ(다단계 피트백 큐) 스케줄링
	작업이 시스템에 들어가면 한 큐에만 고정되는 MLQ의 문제를 해결하기 위한 방법으로, 작업이 큐 사이를 이동할 수 있다.

![](https://i.imgur.com/nwsSo9A.png)

- 프로세스 생성 시 가장 높은 우선 순위 큐에 등록되며, 등록된 프로세스는 먼저온 순서로 CPU를 할당받아 실행된다. 
- 만약 해당 큐의 CPU시간 할당량이 끝나면, 한 단계 아래의 준비 큐에 들어간다. 단계가 내려갈수록 시간 할당량이 증가한다. 하지만 큐의 우선순위는 낮아진다.
- 가장 하위 큐는 FCFS 스케줄링이다. 
- 만약 맨 아래 큐에서도 너무 오래 대기하면 다시 상위 큐로 이동한다. (에이징 기법을 통한 기아 현상 예방)

- 장점
	1. 프로세스를 여러 큐로 나누어 긴 프로세스가 CPU에서 너무 오래 실행되지 않도록 하여 대기시간을 줄인다.
	2. 프로세스가 공정하게 실행될 수 있도록 한다.
	3. 기아상태를 예방한다.


---
