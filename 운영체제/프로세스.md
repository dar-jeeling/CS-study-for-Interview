> 프로세스 : 프로그램, 프로세스, 스레드 / PCB / 프로세스 생성 과정 / 데몬 프로세스 / 컨텍스트 스위칭

# 1. 프로세스

### 프로그램, 프로세스, 스레드

- 프로그램 : 디스크에 존재하는 실행을 위한 코드와 데이터의 묶음.
- **프로세스** : 실행 중인 프로그램. 프로그램을 **실행**하게 되면, 프로그램이 디스크에서 메모리로 적재되어, CPU에 의하여 메모리의 일정 공간을 할당받게 된다(이렇게 할당 받아서 프로세스가 접근할 수 있는 메모리를 **address space**라고 한다) . 이렇게 메모리에 올라가 있는 프로그램을 프로세스라고 한다.
  - **프로세스가 할당 받은 메모리 공간은 다른 프로세스와 공유되지 않는다.** 따라서 한 프로세스가 다른 프로세스에 접근하려면 프로세스 간의 통신 (IPC, inter-process communication)을 통해야 한다.
  - 프로세스는 프로세스 스택(함수의 매개변수, return address, 로컬 변수와 같은 값을 가짐)과 전역 변수를 수록하는 데이터 섹션, 동적 할당을 위한 힙을 포함한다.
- **스레드** : **프로세스 내**에서 실행되는 **프로그램 흐름의 단위**. 즉, **같은 프로세스에서 사용되는 개념**으로 프로세스 내의 스레드들은 **프로세스가 할당받은 메모리와 자원을 공유**한다. 하나의 프로세스를 여러 개의 스레드로 구분하여 수행 능력을 향상 시키는 것을 멀티 스레딩이라고 한다.
  - 스레드는 프로세스의 자원과 메모리를 공유하므로 동기화 문제를 야기하기도 한다. 이를 해결하기 위해 뮤텍스나 세마포어와 같은 방식을 사용한다.
  - 스레드는 스레드 ID , 프로그램 카운터, 레지스터 집합, 스택으로 구성된다.
    - 프로세스 내에서 실행 흐름을 나누는게 스레드 이므로, 각 독립적인 실행흐름을 정> 의하기 위하여 스택과 스레드 내부의 명령어 흐름을 위하여 PC를 따로 할당한다.

이러한 프로세스와 스레드의 관리는 운영체제가 담당하며, 운영체제는 프로세스와 스레드를 스케줄링하여 CPU의 자원을 효율적으로 활용한다. 사용자는 운영체제의 동작을 통하여 여러 프로그램을 동시에 실행하는 것 처럼 느껴지게 하며 (각 프로세스가 자신만의 CPU를 가지고 있는 것 처럼 느껴지게 하며), 시스템의 전반적인 성능 향상을 도모하게 된다.

### PCB (Process Control Block)

- PCB : Process Control Block, 프로세스 제어 블록을 의미한다. 이는 **프로세스에 대한 중요한 정보를 저장**하고 있는 운영체제의 자료 구조이다. 각 프로세스 마다 **독립적인 PCB**를 가진다. 이러한 PCB는 Context Switching 과 같은 프로세스 전환을 할 때, 현재 실행하고 있던 프로세스의 PCB 정보를 저장하고 프로세스를 전환하였다가, 다시 원래의 프로세스로 돌아올 때 PCB 정보를 보고 이전의 작업을 계속 수행하게 된다.
- 구성 요소 : **프로세스 식별자(PID), 자신을 호출한 부모 프로세스의 아이디(PPID)**, 프로세스 상태, PC, CPU 레지스터, CPU 스케줄링 정보, 메모리 관리 정보, 입출력 상태 정보, 어카운팅 정보 등

- PCB를 통하여 운영체제가 프로세스를 효율적으로 관리하고 스케줄링 할 수 있다.
  - 운영체제는 모든 프로세스의 상태를 추적해야해서, 이 상태를 가지는 queue를 가진다. ready queue와 wait queue를 가지며 이 queue에 pcb가 들어있다. 각 pcb는 현재 상태에 대해서 적합한 state queue에 들어가 있다. (상태가 ready면 ready queue, i/o 같은거 기다리면 wait queue)

### 프로세스와 스레드의 생성

- 프로세스의 생성 : linux 환경 (unix 시스템)에서 프로세스를 생성하기 위해서 `fork()` 시스템 콜과 `exec()` 시스템 콜을 이용하게 된다.

  1.  `fork()` : `fork()`를 **실행한 프로세스를 복제하여 새로운 프로세스를 생성**한다. 이렇게 생성된 프로세스를 자식 프로세스라고 합니다.`fork()`를 통해 만들어진 새로운 프로세스는 자신을 호출한 프로세스의 상태와 거의 같은 값을 가지나 **unique 한 PID 값을 가지고 PPID 값으로 부모 프로세스의 PID 값을 가진다.**
  2.  `exec()` : 프로세스의 이미지를 새로운 프로그램의 이미지로 대체하기 위하여 `exec()`를 실행한다. `exec()` 시스템 콜은 새로운 프로세스를 생성하지는 않는다. `exec()` 을 호출하면 현재 프로세스의 메모리 공간에 새로운 프로그램이 로드되고 실행된다. 이 시스템 콜 이후 부터의 코드는 새로운 프로그램에서 정의한 대로 실행된다.

- 스레드의 생성 : 라이브러리의 `pthred_create()`를 호출하여 새 스래드를 생성하고 성공하면 0을 반환하고 실패하면 오류 번호를 반환한다. 이 때 생성된 스레드는 같은 프로세스 내에서 메모리 공간을 공유한다.

### Zombie Process, Orphan Process

- **Zombie Process** : 자식 프로세스가 상태를 알리지 않고 죽는다면, 커널은 자식 프로세스의 데이터를 잠시 저장하게 된다. 이렇게 **프로세스 자체는 종료되었으나 커널에 데이터가 남아있는, 즉 프로세스가 완전히 삭제되지 않는 상태를 zombie process라고 한다**. 이러한 zombie process는 부모 프로세스에서 wait() 시스템 콜을 호출하여 자식 프로세스의 상태 정보를 수집하거나, 부모 프로세스가 종료된다면 (자식 프로세스의 데이터에 PPID가 있으므로) zombie process가 제거 됩니다.
- **Orphan Process** : **부모 프로세스가 먼저 죽는다면, 자식 프로세스는 부모를 잃게 되는 orphan process 상태**가 된다. linux에서는 이를 처리하기 위해 특별한 프로세스인 **init process (PID가 1인 프로세스)를 두어** 부모 프로세스가 죽으면 **자식 프로세스의 PPID를 1로 설정하고, init process가 이러한 프로세스를 관리**하게 된다. (이 init 프로세스는 정기적으로 wait() 시스템 콜을 호출하여 자식 프로세스의 상태를 관리) 따라서 부모 프로세스가 먼저 죽더라도 자식 프로세스가 zombie process가 되는 것을 방지할 수 있다.

### 데몬 프로세스

- 데몬 프로세스 : **백그라운드에서 실행되는 프로세**스로 시스템의 핵심 기능을 위하여 수행되거나 서비스를 제공하기 위하여 대기하는 서버 역할을 하기도 한다. 데몬 프로세스의 예로 웹 서버, 메일 서버, 로그 서버와 같은 것들이 있다. 이 프로세스는 사용자 세션과 무관하게 시스템이 부팅될 때 시작되고 시스템이 종료될때 까지 실행됩니다. **데몬 프로세스는 끝에 `d`를 붙임으로써 다른 프로세스와 구별**합니다. 데몬 프로세스는 **일반적으로 부모 프로세스를 가지지 않으며 시스템에 의해 직접 관리**됩니다.

### 컨텍스트 스위칭

- **컨텍스트 스위칭** : CPU가 **하나의 프로세스에서 다른 프로세스로 상태 정보가 바뀌는 것**을 의미한다.
  예를 들어 프로세스 A에서 프로세스 B로 컨텍스트 스위칭이 일어난다고 하자. 이러한 과정은 커널 모드에서 실행한다. 운영체제는 프로세스 A에게 할당한 CPU와 메모리를 회수한 후 PCB에 프로세스 A 정보를 저장한다. 이 후, 기존의 프로세스 B의 PCB 정보를 리로드하고 CPU와 메모리를 프로세스 B에 할당한다. 이 후에 프로세스 B가 계속 실행되게 된다.
- 프로세스, 스레드의 컨텍스트 스위칭의 차이점
  프로세스와 스레드의 차이점 중 하나는 '**독립된 주소 공간의 유무**'이다. **프로세스의 경우 독립된 주소 공간을 가지고, 스레드의 경우 하나의 프로세스의 실행 단위 이므로 한 프로세스의 주소 공간을 공유**하게 된다. **따라서 프로세스의 컨텍스트 스위칭 시에는 주소 공간에 대한 변경이 필요하며 이에 따른 오버헤드(메모리 맵을 교체해야하는 비용)가 발생**한다. 반면 스레드의 경우 한 프로세스에서 주소 공간을 공유하므로 주소 공간에 따른 오버헤드가 없다. 따라서 프로세스의 컨텍스트 스위칭 보다 스레드의 컨텍스트 스위칭이 더욱 효율적으로 일어날 수 있다.

스레드의 개념이 추가되고 나서는 스케줄러한테 프로세스를 모르고 스레드만 알고,,
그래서 스레드 단위로만

**컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보는 어떠한 형식으로 저장되나요?**
컨텍스트 스위칭이 일어날 때, 현재 실행 중인 프로세스나 스레드의 상태 정보를 커널 스택에 저장하게 되는데 이러한 정보를 '컨텍스트'라고 합니다. **이 컨텍스트는 PCB 형식으로 저장하며 PCB 형식에는 프로세스가 나중에 중단된 지점 부터 다시 실행할 수 있는 정보 (프로세스의 실행 상태, CPU 레지스터의 상태, 메모리 관리 정보) 등을 저장**하게 됩니다.

- **컨텍스트 스위칭이 일어나는 시점**
  - 타이머 인터럽트, I/O 작업, 운영 체제가 더 높은 우선 순위의 프로세스를 실행해야 할 경우
  - 멀티 태스킹 환경에서 스케줄링 정책에 따라 다른 프로세스에 CPU가 할당될 때
  - 인터럽트가 발생했을 때 : 인터럽트 서비스 루틴을 실행하기 위함
    - I/O 작업을 요청하였을 때
  - 프로세스가 자발적으로 CPU를 양도했을 때
