
### Persistent Storage : 영속 저장장치

- 하드 디스크 드라이브
- SSD (solid state storage device)

전력이 차단되어도 데이터를 유지하는 스토리지에 정보를 저장한다.
우리는 **File**과 **Directory**라는 추상화된 데이터 관리 인터페이스로써 접근할 수 있다.

### 파일 시스템 계층

![](https://i.imgur.com/TNjKt6j.png)

유저 레벨의 소프트웨어는 주로 라이브러리를 통해 파일 시스템에 접근한다. 예로 C언어의 파일 표준 IO의 경우, `printf`, `scanf` 등이 존재한다. 

그러한 라이브러리의 메소드로 유닉스 계열의 운영체제에서 표준으로 사용되는 POSIX API로 파일 관리 시스템에 특정 요청을 할 수 있다. 파일 시스템은 파일과 디렉토리 구조를 유지하는 형태이며, Block 계열의 디바이스들의 경우 **파일 시스템**은 위 그림과 같이 block 계층들을 거처 실제 하드 디스크에 저장된 데이터에 접근하게 된다.

#### Block 디바이스란
- 하드디스크, SSD, CD 등의 블록이나 섹터 등의 정해진 단위로 데이터를 전송하는 장치
- 블록으로 구성되며 각 블록은 데이터를 저장하는데 사용하는 고정 크기의 메모리 영역
- ↔️ 캐릭터 디바이스 (키보드, 마우스, 모니터, 프린터) : byte단위

블록 디바이스는 위 그림과 같이 *Generic Block Layer*를 가지는데 스케쥴링과 입출력 요청을 생성하는 역할을 한다.

### 저장공간의 추상화

![](https://i.imgur.com/9FqZYaI.png)

운영체제에서는 메모리 공간에 접근할 때 최소 단위 Block 으로 추상화된 형태로 사용한다. 플래터가 어쩌고, 실제 위치가 어쩌고 그런건 하드웨어의 펌웨어가 처리할 부분이고 운영체제에서는 알 수 없으며 block 인터페이스로 통신한다.

#### 파일 시스템 인터페이스
- `Identify()` : 현재 블럭이 몇개?
- `Read(start, count)` : start로 부터 count개의 섹터를 읽기
- `Write(start, count)` : start로부터 count개의 섹터 쓰기

#### 파일 File
- 관련된 정보를 하나로 묶어 집합으로 만든 형태이다. (당연하죠?)
- 각각의 파일은 **독립적인 번호를 가진다**. 이를 **inode number**라고 한다.
- 아이노드 번호는 파일 시스템 안에서 **유일해야한다**.

#### 디렉토리 Directory
![](https://i.imgur.com/HbSmmHt.png)

디렉토리는 파일들을 조직화하는 기능을 제공한다. 이도 **일종의 파일**이다!!. 근데 특별한 목적을 가지는... 디렉토리는 <파일 이름, 아이노드 번호>의 해당 디렉토리에 속한 파일의 정보들을 가진다.

- 디렉토리는 계층적인 형태로, **트리와 같은 구조**를 가진다.
- 최상위 디렉토리를 Root, 하위 디렉토리를 Sub

### 파일 시스템 기초

각각의 파일은 두 가지 데이터로 이루어진다. 
1. 사용자의 데이터 - byte의 연속 
2. 파일의 메타데이터 (inode)
	- 파일 크기
	- 소유자
	- 접근 권한 RWE
	- 타임 스탬프 (만든 시간, 생성 시간)
	- 블록 위치 (실제 파일 내용이 어디 저장 되어있는지)

![](https://i.imgur.com/pyPpOlp.png)

아이노드(inode)라는 구조체에 POSIX 표준의 경우  위와 같은 정보들이 저장되어진다

![](https://i.imgur.com/gEj6Uw2.png)

결국 파일 시스템에서는 <파일이름, 실제 데이터, 메타 데이터> 등의 여러 블록으로 구성되어 이루어진다. 그렇다면 How? 어떻게 이러한 여러 블록들을 연결해 줄 것인가? 이를 연결해주는 것이 파일 시스템의 역할이다.

#### 파일 시스템을 구현한다면?
- 어떠한 정보를 메타 데이터에 저장할지?
- 어떻게 파일의 메타데이터를 위치 시킬 것인가?
- 메타데이터로 부터 어떻게 실제 데이터 블록을 찾을 것인가?
- 어떻게 메타데이터와 실제 데이터를 관리할 것인가?
	- 할당/반환/여유공간관리 등
- 파일 시스템의 충돌(일관성의 깨짐)의 경우 어떻게 복구할 것 인가?

### 파일 시스템 읽기

#### 파일 데이터에 접근하고 싶다면?
![](https://i.imgur.com/fm6dzS5.png)

1. 파일 이름을 찾는다
2. 파일 이름으로 디렉토리에 저장된 아이노드 번호를 찾는다.
3. 아이노드 번호로 아이노드 구조체로 메타데이터를 찾는다.
4. 아이노드의 정보로 실제 파일데이터에 접근한다.

예제로 생각해보자. 유저 레벨 소프트웨어에서 입출력 라이브러리의 함수로 저장장치의 데이터에 접근하는 과정을 살펴본다.  `open("a/b/c.txt")` 의 경우
1. 루트의 위치 `/` 를 가지온다 (이는 항상 알 수 있음)
2. 루트 디렉토리에서 `a` 아이노드를 찾아 위치를 구한다.
3. `a` 디렉토리를 열어 `b` 아이노드를 찾고 위치를 구한다.
4. `b` 디렉토리를 열어 `c` 아이노드를 찾고 위치를 구한다.
5. `c` 파일을 연다.

이 때 각 단계에서 권한을 매번 체크한다. 이러한 과정들은 순서대로 이루어지기 때문에 시간이 오래걸리는 작업이다. 따라서 OS에서는 prefix lookup 캐싱을 통해 성능을 향상 시킨다.

*ℹ️  파일 이름은 경로를 포함한 이름이다*

### 파일 시스템 쓰기

문서를 작성할 때마다 wrtie 연산을 수행한다면 비효율적일 것이다. 이에 OS에서는 **write buffer**를 사용하여 메모리에만 반영하고 대기하다가 **일정 주기로 한번에 기록**한다. 이로 인해 성능을 향상 시킬 수 있다.

- 리눅스에서는 defalut `30초`
- `fsync()` 라는 시스템콜로 강제로 flush할 수 있다
	- 디스크 내부의 캐시까지도 실제 디스크에 반영된다.
- `fdatasync()` 는 meta 데이터 제외하고 실제 데이터만 반영

```c
int fd = open("foo", O_CREATE | O_WRONLY | O_TRUCNC);
int rc = write(fd, buffer, size);
rc = fsync(fd);
close(fd);
```

### 하드 링크와 심볼릭 링크 (linux only)

#### 하드 링크
: 기존 파일과 이름이 다르지만, 같은 inode 번호를 가지는 파일이다.
> `ln old.txt new.txt` 

```bash
> ln -i file file2
67158084 file
67158084 file2
```

- `old.txt`와 `new.txt` 는 이름만 다르지 같은 파일이다.
- 원본과 복사본을 구별할 수 없음
- 실제 데이터에 대한 여러가지 이름을 가진다고 생각

inode에서는 하드링크의 개수를 세고 있으며, 0이 되는 순간 실질적으로 삭제된다. 
즉 하드 링크가 여러개인 파일에서 하나를 지운다해도 삭제되는 것이 아님.

#### 심볼릭 링크 (소프트 링크)
: 기존 파일의 경로를 가지는 파일이다.
> `ln -s old.txt new.txt` 

- 윈도우의 바로기기와 동일.
- 링크 전용 파일로 기존의 파일과는 다르며 새로운 inode가 생성된다..
- 하드링크와 다르게 디렉토리에 대한 링크도 생성가능

```bash
> stat file
... regular file ...

> stat file2
... symbolic link ...
```

심볼릭 링크는 파일과 디렉토리와는 다른 **특수한 형태의 파일**이다. 기존 파일에 대한 경로를 가지며 기존 파일과는 다르다.

```bash
> echo hello > file
> ln -s file file2
> cat file2
hello
> rm file
> cat file2
cat: file2: No such file or directory
```

심볼릭 링크의 문제점은 **Dangling reference** 가 발생할 수 있다는 점. 기존 원본을 지우면 symbolic 링크는 아무것도 가르키지 않는다!